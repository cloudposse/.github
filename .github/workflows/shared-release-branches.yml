name: "Shared release branches"

on:
  workflow_call:
    inputs:
      runs-on:
        description: "Overrides job runs-on setting (json-encoded list)"
        type: string
        required: false
        default: '["ubuntu-latest"]'

jobs:
  major-release-tagger:
    runs-on: ${{ fromJSON(inputs.runs-on) }}
    environment: release
    steps:
      - uses: actions/create-github-app-token@v1
        id: github-app
        with:
          app-id: ${{ vars.BOT_GITHUB_APP_ID }}
          private-key: ${{ secrets.BOT_GITHUB_APP_PRIVATE_KEY }}

      - uses: cloudposse/github-action-major-release-tagger@v2
        with:
          token: ${{ steps.github-app.outputs.token }}

  release-branch-manager:
    runs-on: ${{ fromJSON(inputs.runs-on) }}
    environment: release
    steps:
      - uses: actions/create-github-app-token@v1
        id: github-app
        with:
          app-id: ${{ vars.BOT_GITHUB_APP_ID }}
          private-key: ${{ secrets.BOT_GITHUB_APP_PRIVATE_KEY }}

      - uses: cloudposse/github-action-release-branch-manager@v2
        with:
          token: ${{ steps.github-app.outputs.token }}

  release-commenter:
    runs-on: ${{ fromJSON(inputs.runs-on) }}
    steps:
      - uses: actions/github-script@v7
        with:
          result-encoding: string
          retries: 3
          script: |
            release_id = context.payload.release.id;
            
            currentReleaseResponse = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,            
              release_id,
            });
            
            currentRelease = currentReleaseResponse.data;
            
            currentTag = currentRelease.tag_name;
            currentBranch = currentRelease.target_commitish;
            
            releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,            
            });
            
            previousRelease = null;
            
            currentReleaseFound = false;            
            for (release of releases.data) {
              if (currentReleaseFound) {
                previousRelease = release;
                break;
              } else if (release.tag_name == currentTag) {
                currentReleaseFound = true;
              }
            }
            
            if (previousRelease == null) {
              console.log(`No previous release found for ${currentTag}`);
              return;
            }
            
            commitsResponse = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,            
              base: previousRelease.tag_name,
              head: currentRelease.tag_name,
            });
            
            commits = commitsResponse.data;
            
            for (commit of commits.commits) {
              responseCommit = await github.rest.git.getCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,            
                commit_sha: commit.sha,
              });
            }
                        
            const query = `
            {
              resource(url: "${context.payload.repository.html_url}/commit/${commit.sha}") {
                ... on Commit {
                  messageHeadlineHTML
                  messageBodyHTML
                  associatedPullRequests(first: 10) {
                    pageInfo {
                      hasNextPage
                    }
                    edges {
                      node {
                        bodyHTML
                        number
                        labels(first: 10) {
                          pageInfo {
                            hasNextPage
                          }
                          nodes {
                            name
                          }
                        }
                        timelineItems(itemTypes: [CONNECTED_EVENT, DISCONNECTED_EVENT], first: 100) {
                          pageInfo {
                            hasNextPage
                          }
                          nodes {
                            ... on ConnectedEvent {
                              __typename
                              isCrossRepository
                              subject {
                                ... on Issue {
                                  number
                                }
                              }
                            }
                            ... on DisconnectedEvent {
                              __typename
                              isCrossRepository
                              subject {
                                ... on Issue {
                                  number
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            `;
            
            response = await github.graphql(query);            
            
            console.log(response.resource.associatedPullRequests.edges);
            
